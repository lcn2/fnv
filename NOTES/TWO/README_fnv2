#=======================#
# Fowler/Noll/Vo-2 hash #
#=======================#

The basis of this hash algorithm was taken from an idea sent
as reviewer comments to the IEEE POSIX P1003.2 committee by:

     Phong Vo (http://www.research.att.com/info/kpv)
     Glenn Fowler (http://www.research.att.com/~gsf/)

In a subsequent ballot round:

     Landon Curt Noll (http://reality.sgi.com/chongo)

improved on their algorithm.  Some people tried this hash
and found that it worked rather well.  In an EMail message
to Landon, they named it the ``Fowler/Noll/Vo'' or FNV hash.

FNV hashes are architected to be fast while maintaining a low
collision rate. The FNV speed allows one to quickly hash lots
of data while maintaining a reasonable collision rate.  See:

     http://reality.sgi.com/chongo/tech/comp/fnv/

for more details as well as other forms of the FNV hash.

Comments, questions, bug fixes and suggestions welcome at:

    chongo_fnv@prime.engr.sgi.com


#====================#
# FNV-2 hash utility #
#====================#

This FNV-2 algorithm is under development and has not been fully
tested.  Use of this algorithm is not recommended.

Two hash utilities (32 bit and 64 bit) are provided:

	fnv2_32 [-b bcnt] [-m [-v]] [-s arg] [arg ...]
	fnv2_64 [-b bcnt] [-m [-v]] [-s arg] [arg ...]
or:
	fnv232 [-b bcnt] [-m [-v]] [-s arg] [arg ...]
	fnv264 [-b bcnt] [-m [-v]] [-s arg] [arg ...]

	-b bcnt	  mask off all but the lower bcnt bits (default: 32)
 	-m	  multiple hashes, one per line for each arg
	-s	  hash arg as a string (ignoring terminating NUL bytes)
 	-v	  verbose mode, print arg after hash (implies -m)
	arg	  string (if -s was given) or filename (default stdin)

as examples of how to use the FNV hash library.  For those who do
not like _'s, the same tools exist without the _ are provided.  :-)


#====================#
# FNV-2 hash library #
#====================#

The libfnv.a library implements both a 32 bit and a 64 bit FNV-2 hash
on collections of bytes, a NUL terminated strings or on an open file
descriptor.  The FNV-2 hash, while slightly slower will not fix on a
zero hash value and remain there while it processes additional 0 bytes.

The interface to FNV-2 is the same as FNV except that the function
names start with fnv2 instead of just fnv:

	fnv32 fnv2_32_buf(char *buf, int len, fnv32 *hval);	/* byte buf */
	fnv32 fnv2_32_str(char *string, fnv32 *hval);		/* string */
	fnv32 fnv2_32_fd(int fd, fnv32 *hval);			/* open file */
or:
	fnv32 fnv2_32_buf(char *buf, int len, NULL);		/* byte buf */
	fnv32 fnv2_32_str(char *string, NULL);			/* string */
	fnv32 fnv2_32_fd(int fd, NULL);				/* open file */

Here is the 64 bit FNV hash:

	fnv64 fnv2_64_buf(char *buf, int len, fnv64 *hval);	/* byte buf */
	fnv64 fnv2_64_str(char *string, fnv64 *hval);		/* string */
	fnv64 fnv2_64_fd(int fd, fnv64 *hval);			/* open file */
or:
	fnv64 fnv2_64_buf(char *buf, int len, NULL);		/* byte buf */
	fnv64 fnv2_64_str(char *string, NULL);			/* string */
	fnv64 fnv2_64_fd(int fd, NULL);				/* open file */

=-=

chongo <Landon Curt Noll> /\oo/\
http://reality.sgi.com/chongo
chongo_fnv@prime.engr.sgi.com

Share and Enjoy!
