#=======================#
# Fowler/Noll/Vo-0 hash #
#=======================#

The basis of this hash algorithm was taken from an idea sent
as reviewer comments to the IEEE POSIX P1003.2 committee by:

     Phong Vo (http://www.research.att.com/info/kpv)
     Glenn Fowler (http://www.research.att.com/~gsf/)

In a subsequent ballot round:

     Landon Curt Noll (http://reality.sgi.com/chongo)

improved on their algorithm.  Some people tried this hash
and found that it worked rather well.  In an EMail message
to Landon, they named it the ``Fowler/Noll/Vo'' or FNV hash.

FNV hashes are architected to be fast while maintaining a low
collision rate. The FNV speed allows one to quickly hash lots
of data while maintaining a reasonable collision rate.  See:

     http://reality.sgi.com/chongo/tech/comp/fnv/

for more details as well as other forms of the FNV hash.

Comments, questions, bug fixes and suggestions welcome at:

    chongo_fnv@prime.engr.sgi.com


#====================#
# FNV-0 hash utility #
#====================#

This is the original historic FNV algorithm with a 0 offset basis.
It is recommended that FNV-1, with a non-0 offset basis be used instead.

Two hash utilities (32 bit and 64 bit) are provided:

	fnv0_32 [-b bcnt] [-m [-v]] [-s arg] [arg ...]
	fnv0_64 [-b bcnt] [-m [-v]] [-s arg] [arg ...]
or:
	fnv032 [-b bcnt] [-m [-v]] [-s arg] [arg ...]
	fnv064 [-b bcnt] [-m [-v]] [-s arg] [arg ...]

	-b bcnt	  mask off all but the lower bcnt bits (default: 32)
 	-m	  multiple hashes, one per line for each arg
	-s	  hash arg as a string (ignoring terminating NUL bytes)
 	-v	  verbose mode, print arg after hash (implies -m)
	arg	  string (if -s was given) or filename (default stdin)

as examples of how to use the FNV hash library.  For those who do
not like _'s, the same tools exist without the _ are provided.  :-)


#====================#
# FNV-0 hash library #
#====================#

The libfnv.a library implements both a 32 bit and a 64 bit FNV hash
on collections of bytes, a NUL terminated strings or on an open file
descriptor.

Here is the 32 bit FNV hash:

	fnv32 fnv0_32_buf(char *buf, int len, fnv32 *hval);	/* byte buf */
	fnv32 fnv0_32_str(char *string, fnv32 *hval);		/* string */
	fnv32 fnv0_32_fd(int fd, fnv32 *hval);			/* open file */

Here is the 64 bit FNV hash:

	fnv64 fnv0_64_buf(char *buf, int len, fnv64 *hval);	/* byte buf */
	fnv64 fnv0_64_str(char *string, fnv64 *hval);		/* string */
	fnv64 fnv0_64_fd(int fd, fnv64 *hval);			/* open file */

If hval is NULL, then only the FNV hash of the first arg (buffer or string)
will be returned.  If hval is non-NULL, then its value will be used as
an initial FNV hash value and on return it will be updated with the
returned value.  For example:

	fnv64 hash_val;

	hash_val = fnv0_64_str("a string", NULL);
	(void) fnv0_64_str("more string", &hash_val);

produces the same final hash value as:

	hash_val = fnv0_64_str("a stringmore string", NULL);

NOTE: If you system has a 64 bit 'unsigned long long' data type, then
fnv64 will be an unsigned long long; otherwise fnv64 will be a structure
containing 2 unsigned long's.

=-=

chongo <Landon Curt Noll> /\oo/\
http://reality.sgi.com/chongo
chongo_fnv@prime.engr.sgi.com

Share and Enjoy!
